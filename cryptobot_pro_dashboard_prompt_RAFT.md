Ниже описана моя задача для тебя, Cursor.

---

# Задача: Единый CryptoBot Pro Dashboard (Live / Backtest / Debug + AI)

## 0. Цель

Сделать один единый CryptoBot Pro Dashboard, который:

- Показывает реальные данные (свечи, PnL, сделки, риск).
- Имеет режимы: **Live / Backtest / Debug**.
- Имеет полезный **AI-ассистент**, а не просто красивую сферу.
- Выглядит как **единый продукт**, а не набор экспериментов.
- Собирается, запускается и коммитится **одной стабильной командой**.

---

## 1. Архитектура и порядок в проекте

### 1.1. Один главный дашборд

**Задача 1.1.1 — Выбрать и зафиксировать основной маршрут**

- Оставить один основной маршрут: `/dashboard`.
- Решить:
  - `dashboard.html` — основной шаблон.
  - `dashboard_new.html` → либо удалить, либо перенести в условный `/labs` или `/archive`.

✅ Готово, когда:

- В браузере есть только один основной адрес для работы: `/dashboard`.
- Нет путаницы, где «настоящий» дашборд.

---

### 1.2. Очистка мусора и дублей

**Задача 1.2.1 — Удалить/архивировать экспериментальные UI-файлы**

Всё, что:
- не подключается в `server.py`,
- не используется в актуальном HTML-шаблоне,
- продублировано или является старым вариантом (`bak`, `old`, прототипы),

— либо удаляем, либо выносим в `/archive` (или аналогичную папку).

✅ Готово, когда:

- `web/templates/` содержит только реально используемые шаблоны.
- `web/static/js/` и `web/static/css/` без «свалки» экспериментальных/устаревших файлов.

---

### 1.3. Починить git и инфраструктуру

**Задача 1.3.1 — Разобраться с ошибкой `git commit`**

- Проверить:
  - наличие и состояние `submodules` / `subprojects`,
  - наличие и конфигурацию `pre-commit` hooks,
  - корректность настроек любых вложенных репозиториев.
- Добиться, чтобы команда `git commit -m "..."` работала **без ошибок**, без костылей.

✅ Готово, когда:

- Любые изменения по проекту можно зафиксировать одним `git commit` без падения.

---

## 2. Фронтенд: единая структура и логика

### 2.1. Единая точка входа для JS

**Задача 2.1.1 — Ввести модульную структуру JS**

Создать/упорядочить структуру:

- `web/static/js/cbp_state.js`
- `web/static/js/cbp_ws.js`
- `web/static/js/cbp_charts.js`
- `web/static/js/cbp_ai.js`
- `web/static/js/cbp_ui.js`
- `web/static/js/cbp_dashboard_main.js`

Роли модулей:

- `cbp_state.js` — глобальное состояние дашборда.
- `cbp_ws.js` — WebSocket (live, AI, возможно backtest при необходимости).
- `cbp_charts.js` — работа с графиком (Lightweight Charts: свечи, сделки, overlays).
- `cbp_ai.js` — логика AI (запросы к backend/модели, обработка AI-ответов, трансформация в структуру).
- `cbp_ui.js` — обновление DOM, лейаут, метрики, видимость блоков по режимам.
- `cbp_dashboard_main.js` — точка входа, инициализация всего (state, WS, графики, AI, UI).

✅ Готово, когда:

- В HTML подключается только **один** основной JS-файл: `cbp_dashboard_main.js`.
- Вся логика дашборда разложена по указанным модулям, нет зоопарка `dashboard.js`, `backtest.js`, `dashboard_new.js` и т.п.

---

### 2.2. Один тип графиков

**Задача 2.2.1 — Отказаться от Chart.js в дашборде**

- Все графики (Live + Backtest) перевести на **Lightweight Charts**.
- Chart.js:
  - либо полностью убрать из дашборда,
  - либо изолировать в /labs, если нужен только для экспериментов.

✅ Готово, когда:

- В интерфейсе используется только **одна** библиотека графиков — Lightweight Charts.
- Код обновления графика (candles, trades, overlays) сосредоточен в `cbp_charts.js`.

---

### 2.3. Режимы: Live / Backtest / Debug

**Задача 2.3.1 — Ввести режимы в state**

В `cbp_state.js`:

```js
export const dashboardState = {
  mode: "live", // "live" | "backtest" | "debug"
  symbol: "BTCUSDT",
  timeframe: "15m",
  // ... другие поля состояния (selectedStrategy, aiData, backtestResult, wsStatus и т.д.)
};
```

**Задача 2.3.2 — UI-переключатель режимов**

- Добавить в шапку UI (topbar) переключатель (tabs/кнопки):
  - **Live**
  - **Backtest**
  - **Debug**
- При переключении:
  - меняется `dashboardState.mode`,
  - UI адаптируется:
    - видимость/доступность контролов,
    - режим работы с API / WS,
    - какие блоки показывать (например, форма для backtest-параметров и блок «Backtest Result» — только в Backtest).

✅ Готово, когда:

- Режим выбирается в **одном месте**.
- Пользователь всегда понимает, в каком режиме он сейчас (визуально и логически).

---

## 3. Данные и ядро продукта

### 3.1. Реальные данные вместо рандома

**Задача 3.1.1 — Привязать `/api/dashboard` к реальным метрикам**

- Для начала: минимальный набор метрик:
  - текущий PnL по выбранному символу/стратегии,
  - суммарная доходность за день/неделю,
  - уровень риска по открытым позициям (например, через margin usage, VAR, экспозицию).
- Заменить `random`-значения в API и фронтенде на реальные вычисления из `core` (или существующих модулей бота).

✅ Готово, когда:

- При обновлении дашборда данные соответствуют **реальному состоянию бота/биржи**, а не рандому.

---

### 3.2. Связка backtest → дашборд

**Задача 3.2.1 — API для бэктеста**

Добавить эндпоинт, например: `POST /api/backtest/run`:

- **Вход**:
  - стратегия,
  - символ,
  - период (from/to или диапазон),
  - параметры стратегии (risk, leverage, filters и т.п.).
- **Выход** (JSON):
  - свечи,
  - сделки,
  - метрики:
    - PnL,
    - Max Drawdown,
    - Win Rate,
    - и при необходимости дополнительные: Sharpe, Profit Factor и т.п.

**Задача 3.2.2 — Визуализация результатов**

В `cbp_charts.js`:

- функция `renderBacktestResult(candles, trades, metrics)`:
  - рендер свечей,
  - отображение сделок (markers/overlays),
  - отдельный блок метрик.

В UI:

- отдельный блок **«Backtest Result»** с основными метриками (PnL, MaxDD, WinRate и др.).

✅ Готово, когда:

- В режиме **Backtest** можно:
  - задать параметры,
  - запустить тест,
  - получить видимый результат на графике и в блоке метрик.

---

## 4. AI как ассистент, а не игрушка

### 4.1. Структурировать AI-ответы

**Задача 4.1.1 — Формат AI-данных**

Спроектировать и использовать единый формат AI-ответов, например:

```json
{
  "confidence": 0.82,
  "risk_level": "Medium",
  "summary": "Рынок BTCUSDT показывает умеренный восходящий тренд...",
  "action": "Рекомендуется уменьшить размер позиции до 25% капитала",
  "mode": "live",
  "strategy_comment": "Momentum v2 показывает устойчивую динамику на этом отрезке"
}
```

**Задача 4.1.2 — AI-панель в UI**

- Внизу экрана сделать **широкую AI-панель**, которая отображает:
  - `confidence` (число, бар, индикатор),
  - текст `summary`,
  - блок `action` (что конкретно делать),
  - `strategy_comment` (контекст по стратегии / режиму).

✅ Готово, когда:

- AI даёт **структурированные, читаемые рекомендации**, а не просто число или абстрактный текст.

---

### 4.2. AI-сфера (3D) как индикатор, не ядро

**Задача 4.2.1 — Привязать сферу к реальному `confidence`**

- Из `cbp_ai.js`:
  - обновлять параметры 3D-сферы (скорость, цвет, размер, пульсации) в зависимости от:
    - `confidence`,
    - `risk_level`,
    - возможно, текущего `mode` (live/backtest/debug).

✅ Готово, когда:

- Сфера **визуально отражает состояние рынка/риска** (спокойный / опасный / трендовый), а не живёт своей жизнью, не связанной с данными.

---

## 5. UX/UI и визуальный стиль

### 5.1. Единый дизайн

**Задача 5.1.1 — Обновить `dashboard.css` под единый «нейро-стиль»**

- Взять:
  - структуру старого дашборда (topbar + левый сайдбар + центр + правый блок),
  - визуальный стиль и «glow»-эффекты из нового `style.css` (нейронная, современная эстетика).
- Вынести:
  - цвета в `ui_colors.css` (palette/tokens),
  - базовую типографику (h1, h2, body, caption).

✅ Готово, когда:

- Всё выглядит как **один цельный продукт**, а не как смесь разных версий/эпох.

---

### 5.2. Блок сигналов и логов

**Задача 5.2.1 — «Важные события»**

- Справа сделать блок **«Signals & Events»**, куда падают:
  - новые сигналы,
  - открытия/закрытия позиций,
  - срабатывание стопов.
- Сообщения:
  - «выпрыгивают» при появлении нового сигнала,
  - остаются в списке (история последних N событий).

**Задача 5.2.2 — Разделить системные и торговые логи**

- **Системные**:
  - ошибки,
  - reconnect WS,
  - latency, таймауты.
- **Торговые**:
  - сигналы,
  - сделки,
  - изменения стратегии / режима.

✅ Готово, когда:

- Можно быстро увидеть, что произошло **важного для трейдинга**, не утонув в технических логах.

---

### 5.3. Тексты и язык

**Задача 5.3.1 — Выбрать основной язык интерфейса**

- Либо RU по умолчанию,
- Либо EN по умолчанию (и RU — позже, как локализация).
- Определиться и придерживаться единого базового языка.

**Задача 5.3.2 — Переписать ключевые тексты**

- Короткие, понятные подписи:
  - для кнопок,
  - для режимов,
  - для AI-рекомендаций,
  - для ошибок и нотификаций.

✅ Готово, когда:

- Нет мешанины RU/EN на одном экране.
- Тексты помогают понять, что происходит и что нажать.

---

## 6. Качество, метрики и релизность

### 6.1. Метрики качества

**Задача 6.1.1 — Встроить базовые метрики в код**

Логировать как минимум:

- время от загрузки страницы до первого рендера графика,
- время ответа ключевых API (dashboard, backtest, AI),
- частоту reconnect’ов WebSocket.

✅ Готово, когда:

- Можно хотя бы по логам понять, как быстро и стабильно работает дашборд.

---

### 6.2. Скрипт «одной командой»

**Задача 6.2.1 — Сделать один сценарий запуска**

- Скрипт/команда для macOS/Linux, который:
  - при необходимости чистит кэш/временные файлы проекта,
  - поднимает backend-сервер (FastAPI или то, что используется),
  - открывает `/dashboard` в браузере.
- Примеры:
  - `./run_dashboard.sh`
  - или `make dashboard`.

✅ Готово, когда:

- От «хочу посмотреть дашборд» до открытого UI — **одна команда/один шаг**.

---

## 7. Приоритеты (что делать в каком порядке)

### Спринт 1 — Порядок и архитектура

1. Архивировать/убрать лишние шаблоны и скрипты (1.1, 1.2).
2. Починить git, чтобы нормально коммитить (1.3).
3. Ввести модульную структуру JS и один entry-point (2.1).
4. Оставить один маршрут `/dashboard`.

### Спринт 2 — Функционал и данные

5. Ввести режимы Live / Backtest / Debug (2.3).
6. Привязать `/api/dashboard` к реальным метрикам (3.1).
7. Настроить API для backtest и его визуализацию (3.2).
8. Перевести всё на Lightweight Charts (2.2).

### Спринт 3 — AI и UX

9. Структурировать AI-ответы и AI-панель (4.1).
10. Привязать сферу к реальному состоянию (4.2).
11. Обновить дизайн дашборда под единый стиль (5.1).
12. Добавить блок «Signals & Events» и разделение логов (5.2).
13. Причесать тексты и язык (5.3).
14. Добавить метрики качества + скрипт «одной командой» (6.1, 6.2).

---

# RAFT-Инструкция для тебя, Cursor

## R — Роль

Ты — senior+ инженер и ИИ-разработчик с 15+ годами опыта, специализирующийся на:

- проектировании и рефакторинге сложных систем (backend, frontend, DevOps, скрипты);
- архитектуре (слоистая архитектура, модульность, DI, event-driven, при необходимости — микросервисы);
- работе с существующим кодом: аккуратные правки, без «магии», с сохранением стиля проекта;
- написании надёжного кода под macOS / Linux с учётом реальных ограничений окружения.

Твоя зона ответственности:

- правильно понять задачу и контекст этого проекта (CryptoBot Pro Dashboard),
- спроектировать решение, минимально ломающее текущую архитектуру,
- выдать законченный результат, который можно сразу применить: код, команды, шаги.

---

## A — Действия

1. Внимательно прочитай блок «Задача» выше (цели 0–7), пойми:
   - контекст,
   - цели,
   - ограничения,
   - стек (Python backend + JS frontend, WebSocket, Lightweight Charts и т.д.),
   - уже существующие модули и файлы.

2. Сформулируй список уточняющих вопросов, если есть неоднозначность:
   - по структуре репозитория,
   - по текущим API и форматам данных,
   - по существующим стратегиям и ядру бота,
   - по AI-интеграции,
   - по окружению (Python-версия, менеджер пакетов, запуск).

3. После того как получишь ответы, выполни задачу по спринтам (1 → 2 → 3), включая:
   - анализ текущей структуры проекта (папки, модули, ключевые файлы),
   - предложение архитектурного решения (какие слои/модули/классы/файлы и зачем),
   - реализацию кода или правки в существующих файлах,
   - создание новых модулей (JS/Python) там, где это логично и согласуется с архитектурой,
   - настройку и/или правку API и WebSocket,
   - создание/правку скриптов запуска.

4. Учитывай требования к качеству результата:

   - код компилируется / запускается без ошибок (насколько это возможно из контекста),
   - соответствие стилю проекта (именование, форматирование, структура каталогов),
   - отсутствие «мёртвого» кода, заглушек и неиспользуемых сущностей, если иное не оговорено,
   - минимальное дублирование логики, явное разделение ответственности между слоями/модулями,
   - конфиденциальные данные (ключи, токены, пароли) не хардкодить.

5. Если задача затрагивает существующий проект / репозиторий:

   - работай только с теми файлами и каталогами, которые реально есть или логичны в рамках архитектуры,
   - **не придумывай** несуществующие пути/модули — сначала уточни,
   - при создании новых файлов чётко указывай:
     - полный путь,
     - назначение.

6. Если задача включает терминальные команды / скрипты:

   - команды должны быть безопасны для macOS (без опасных `rm -rf` по общим путям),
   - для каждой критичной команды укажи, что она делает и какой ожидается результат,
   - по возможности добавь команду проверки «что всё ок»:
     - `pytest`, `python -m ...`, `curl` к локальному серверу, `npm test` и т.п.

---

## F — Формат ответа

Всегда оформляй ответ строго по структуре:

### 1. Q&A (Уточняющие вопросы)

- Пронумерованный список вопросов, которые тебе нужны, чтобы выполнить задачу на 100%.
- **Сначала** выводишь только этот блок и ничего не меняешь в коде.
- Не переходи к реализации, пока эти вопросы не закрыты.

### 2. PLAN (План работ)

После того как вопросы закрыты:

- Краткий поэтапный план: шаг 1, шаг 2, шаг 3…
- Для каждого шага:
  - что делается,
  - какой ожидается результат,
  - к какому пункту (0–7) из описания задачи относится.

### 3. CHANGES (Изменения в проекте)

Для каждого файла:

- Полный путь к файлу.
- Если файл новый — пометка `(NEW)`.
- Полное содержимое файла **целиком** в одном блоке кода (не diff), чтобы я мог сразу заменить.

> Важно: не дроби один и тот же файл на несколько блоков — всегда давай финальную, целостную версию.

### 4. COMMANDS (Команды для терминала)

- Список команд в том порядке, в котором их нужно выполнять.
- Каждая команда — в отдельном блоке кода.
- Над каждой командой — краткий комментарий:
  - что она делает,
  - какой результат ожидается (например, «запускает backend на http://127.0.0.1:8000», «собирает фронтенд», «открывает /dashboard в браузере»).

### 5. CHECKS (Самопроверка и валидация)

- Список проверок:
  - как убедиться, что всё работает (запуск сервера, тестов, проверка эндпоинта, UI, логов и т.д.).
- При необходимости — команды для этих проверок:
  - `curl`, `pytest`, `python main.py`, `npm run build` и т.п.
- Отдельно укажи:
  - как проверить, что Live, Backtest и Debug работают как задумано,
  - как убедиться, что AI-панель и сфера корректно обновляются.

### 6. NOTES (Важно / ограничения)

- Кратко перечисли:
  - принятые архитектурные решения,
  - потенциальные риски,
  - что важно не забыть при дальнейшей доработке (например, расширение списка стратегий, локализация, доработка метрик).

---

## T — Тон

- Стиль — строгий, технический, как у senior-инженера.
- Минимум воды, максимум конкретики.
- Не пересказывай задачу — концентрируйся на решении и чётких шагах.
- Все примеры кода и команд должны быть максимально приближены к реальному окружению проекта.

---

## Перед началом работы

**Прежде чем ты начнёшь что-либо менять или предлагать конкретные правки, выведи только блок:**

### `Q&A (Уточняющие вопросы)`

Задай столько шаговых, конкретных вопросов, сколько необходимо, чтобы выполнить задачу по дашборду на 100%.
